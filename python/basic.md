1.文档字符串可以通过name.__doc__来访问，其中name可以是包名也可以是函数名。
2.使用help函数可以获取函数或者包的文档字符串.
	help(os)
	help(os.open)
	help 不带任何参数可以进入help模式，在改模式输入模块名，可以查看模块相关的文档
	help 模式下，输入modules可查看当前所有的modules.
	help 模式下, 输入topics可以查看所有的topics.
	help 模式下，输入modules MODULE_NAME可以查看特定module的帮助信息。

3.使用class的__bases__属性，可以获取类的基类.
4.使用isinstance方法来检查一个对象是否是一个类的实例.
5.想要知道某个对象属于某一个类，可以使用它的__class__属性.
6.使用hasattr方法可已检查某一个对象是否包含某一个属性。
7.使用hasattr(x.'__call__')来检查某个对象是否可以被调用（函数）.
8.使用setattr来为一个对象设置属性.
9.导入一个包以后，可以通过dir(package_name)来获取包内的所有常量，函数，类定义...
	内置函数 dir() 用于查找模块定义的名称。 它返回一个排序过的字符串列表
	dir() 不会列出内置函数和变量的名称。如果你想要这些，它们的定义是在标准模块 builtins 中.
10. __init__方法是提供了一个类的构造函数.
11. __del__方法提供了析构函数的功能，但是其调用时机是随机的，因此不建议使用。
12.当前类和对象可以作为super函数的参数使用，调用函数返回的对象的任何方法都是调用超类的方法，而不是当前类的方法。
13.静态方法没又self参数，并且可以被类本身直接调用.
14.类成员方法在定义时需要名为cls的类似self的参数，类成员方法可以直接使用类名调用。但是cls参数时直接被绑定到类的.
15.想要告知程序本身是做为程序运行还是作为库导入到其他程序，可以使用__name__变量：在main程序中，__name__变量的值为__main__。而在导入模块中该值被设置为模块的名称。
16.获取python模块搜索路径的方法：(也就是说放置在这些路径中模块可以被python解释器找到)
	>>> import sys, pprint
	>>> pprint.pprint(sys.path)
17.可通过修改PYTHONPATH环境变量来告诉python解释器去那里找模块定义.(自定以模块路径)
18.包含模块代码的文件的名字要和模块名一样，再加上.py扩展名.
19.当模块存储在文件中时，包就是模块所在的目录。为了让python解释器将其作为包对待，该目录下必须包含一个__init__.py的文件。为了将模块放在包内，直接将模块放在包目录内即可.
	必须要有 __init__.py 文件才能让 Python 将包含该文件的目录当作包。 这样可以防止具有通常名称例如 string 的目录在无意中隐藏稍后在模块搜索路径上出现的有效模块。 在最简单的情况下，__init__.py 可以只是一个空文件，但它也可以执行包的初始化代码或设置 __all__ 变量
	import 语句使用下面的规范：如果一个包的 __init__.py 代码定义了一个名为 __all__ 的列表，它会被视为在遇到 from package import * 时应该导入的模块名列表。在发布该包的新版本时，包作者可以决定是否让此列表保持更新。包作者如果认为从他们的包中导入 * 的操作没有必要被使用，也可以决定不支持此列表。
20.查看模块包含的内容可以使用dir函数.它会将对象的所有特性（一起模块的所有函数，类，变量等）列出。
21.__all__定义了一个模块的共有接口，它告诉python解释器：从模块导入所有名字代表什么含义.如果没有设置__all___ ， import * 语句会导入模块中所有不以__开头的全局名称.
22.模块的__file__属性可以用来获取模块的源码路径.
23. python3.6 -m pip install Pillow
24. sudo vim /etc/sudoers
	secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
25.可以用help函数来获取某一对象的所有属性.
26.如果想查看是否引入了正确的模块，可以通过打印模块的__file__属性来查看模块路径。通过打印模块的__doc__属性来查看该模块的文档。通过help函数来获取该模块的帮助信息。
27. CPython是python官方的解释器，它用C语言编写。
28. IPython是基于CPython的一个交互式解释器。CPython使用>>>作为提示符，而IPython使用In[序号]:作为提示符。
29. PyPy是另一个Python解释器，它的目标是执行速度。PyPy采用JIT技术，对Python代码进行动态编译，所以可以显著提高Python代码的执行速度。
30. Jython是运行在Java平台上的Python解释器，可以直接将Python代码编译为Java字节码执行。
31. IronPython和Jython类似，只不过IronPython是运行在微软.Net平台上的Python解释器，可以直接把Pyton代码编译为.Net的字节码。
32. 以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号:结尾时，缩进的语句视为代码块。
33. 对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符.
34. 由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。Python对bytes类型的数据用带b前缀的单引号或双引号表示：
		x = b'ABC'
	要注意区分'ABC'和b'ABC'，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。
35. 以Unicode表示的str通过encode()方法可以编码为指定的bytes.
36. 反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法.
37. 要计算str包含多少个字符，可以用len()函数。
38. 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。
39. 解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
	尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。
40. 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator。可以使用isinstance()判断一个对象是否是Iterator对象
	凡是可作用于for循环的对象都是Iterable类型；
	凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列；
41. 既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数.
	编写高阶函数，就是让函数的参数能够接收别的函数
42. 使用__slots__: 如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加name和age属性。为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的__slots__变量，来限制该class实例能添加的属性：
43. 可以对所有实现了__iter__方法的对象行进迭代。__iter__方法返回一个迭代器（iterator)，所谓的迭代器就是实现了__next__方法的对象.next函数其实就是调用了迭代器的__next__方法。
43. 一个实现了__iter__方法的对象是可迭代的，一个实现了__next__方法的对象是迭代器。
    给你的类添加迭代器行为很容易: 定义一个 __iter__() 方法来返回一个带有 __next__() 方法的对象。 如果类已定义了 __next__()，则 __iter__() 可以简单地返回 self:
44. 凡是可用作for循环的对象都是Iterable类型。凡是可用作于next()函数的对象都是Iterator类型，它表示一个惰性计算的序列。
45. 集合数据类型如list, dict, str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。
46. python的for循环本质上就是通过不断调用next()函数实现的。
47. 使用type()函数来获取一个对象的类型。
48. 先定义metaclass，然后创建类，最后就可以创建类的实例了。metaclass允许你创建类或者修改类，换句话说，你可以把类看成是metaclass创建出来的实例。
49. Generator 是一个用于创建迭代器的简单而强大的工具。 它们的写法类似标准的函数，但当它们要返回数据时会使用 yield 语句。 每次对生成器调用 next() 时，它会从上次离开位置恢复执行（它会记住上次执行语句时的所有数据值）。
	可以用生成器来完成的操作同样可以用基于类的迭代器来完成。 但生成器的写法更为紧凑，因为它会自动创建 __iter__() 和 __next__() 方法。
	另一个关键特性在于局部变量和执行状态会在每次调用之间自动保存。 这使得该函数相比使用 self.index 和 self.data 这种实例变量的方式更易编写且更为清晰。
	除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发 StopIteration。 这些特性结合在一起，使得创建迭代器能与编写常规函数一样容易
50. 某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，将外层为圆括号而非方括号。 这种表达式被设计用于生成器将立即被外层函数所使用的情况。 生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存
51. 模块对象有一个秘密的只读属性 __dict__，它返回用于实现模块命名空间的字典；__dict__ 是属性但不是全局名称。 显然，使用这个将违反命名空间实现的抽象，应当仅被用于事后调试器之类的场合。
52. 装饰器本质上是一个python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志，性能测试，事务处理，缓存，权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码病继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。	
53. Special forms of parameters:
	• *args: any number of positional arguments packed into a tuple
	• **kwargs: any number of keyword arguments packed into a dictionary
54. 把一个类作为迭代器使用需要在类中实现两个方法__iter__()和__next__(). __iter__()方法返回一个特殊的迭代器对象，这个迭代器对象实现了__next__方法并通过StopIteration异常标识迭代的完成。__next__方法会返回下一个迭代器对象.
